# lua与c++的交互

> 在书写策略时，一定会遇到lua层需要获取c++的数据，或调用c++的函数等交互的需求。本文会举例说明在Rocos系统中多种不同的lua与c++的交互方式，并进行应用场景的比较。

## 总览
lua作为一种胶水语言，其与宿主语言c/c++的交互是必不可少的。在Rocos中，我们将交互分为三类
* **c/c++对lua的解释执行**
* **lua调用c/c++的函数**
* **使用tolua++框架进行交互**

## c++对lua的解释执行
由于lua的解释器是由c编写，从c/c++到lua的调用可以理解为：将lua语言作为整个字符串交给解释器执行。在Rocos中，体现为对于lua脚本的调用执行，对于的函数为`LuaModule`中的`RunScript(name)`。
该函数分别在`DecisionModule`的初始化和每一帧执行中分别对`StartZeus.lua`和`SelectPlay.lua`进行了调用。

## lua调用c/c++的函数
相较于c++对lua的解释执行的单一性来说，在具体执行lua时多次进行与c/c++的交互更为常见。总结来说，**lua对于c的调用都是通过lua的虚拟栈来完成的**。我们以`rocos`中的`CGetSettings`为样例，展示lua对c函数的调用。该函数的作用是获取配置中的相应参数所对应的值，例如通过获取`IsYellow`来判断当前是否为黄方。

在`LuaModule.cpp`中，有这样一段代码：
```c++
extern "C" int FUNC_GetSettings(lua_State* L){
    QString key(LuaModule::Instance()->GetStringArgument(1, NULL));
    QString type(LuaModule::Instance()->GetStringArgument(2, NULL));
    if(type == "Bool"){
        bool temp;
        ...
        LuaModule::Instance()->PushBool(temp);
        ...
    }
    return 1;
}
```
开头的`extern "C"`表示这是一段c语言的代码，这段代码定义了一个函数，类型为：
```c
typedef int (*lua_CFunction) (lua_State *L);
```
任何用于被lua调用的函数通常包含`取`和`存`两个步骤，`取`是为了获取从lua传入的参数，`存`是为了将执行的返回值还给lua。在上述函数中，通过调用了`LuaModule`封装过的`GetStringArgument`来获取第一和第二，两个字符串类型的参数，通过`PushBool`将结果存入栈中返回给lua使用。类似的调用接口还有：
```c++
// 获取参数
GetStringArgument();
GetNumberArgument();
GetBoolArgument();
// 存入返回值
PushString();
PushNumber();
PushBool();
```
这些定义都是在`LuaModule`中对于lua的原有c-api的再次封装。

上述定义好的函数，被存放在一个键值对数组中(`LuaModule.cpp:GUIGlue`)，相关的定义如下：
```c++
luaDef GUIGlue[] = {
    ...
    {"CGetSettings", FUNC_GetSettings}, // 定义函数在lua中的symbol
    ...
	{NULL, NULL} // 定义键值对数组的末尾值
};

```
完成上述两步后，我们可以在lua中使用`CGetSettings`对函数进行调用。

在rocos中，从lua的task中对于c++/Skill的调用也使用了类似的方法。不过在即将到来的`v0.1`版本中，我们将使用`tolua++`的交互方式代替现有的方式，以此来规避掉创建一个新的c++的skill时的繁琐的书写方式。

## 使用tolua++框架进行交互[TODO]



###### 参考资料：
* [C++/Lua交互指南](https://zhuanlan.zhihu.com/p/40406096)
* [CppCon 2017: Andreas Weis “Howling at the Moon: Lua for C++ Programmers”](https://youtu.be/pfwHCiP1HFM?si=-xGuvergVM6cnLZH)